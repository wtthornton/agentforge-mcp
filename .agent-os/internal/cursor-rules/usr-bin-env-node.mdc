# !/usr/bin/env node

#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const glob = require('glob');

class CursorInit {
  constructor() {
    this.sourceDir = '.agent-os';
    this.outputDir = '.cursor/rules';
    this.generatedDir = '.cursor/generated';
  }

  async run() {
    console.log('🚀 Starting Cursor init process...');
    
    // 1. Discover source files
    const sourceFiles = this.discoverSourceFiles();
    console.log(`📁 Found ${sourceFiles.length} source files`);
    
    // 2. Analyze content
    const analyzedContent = this.analyzeContent(sourceFiles);
    console.log(`📊 Analyzed ${analyzedContent.length} content sections`);
    
    // 3. Generate rules
    const generatedRules = this.generateRules(analyzedContent);
    console.log(`⚙️ Generated ${generatedRules.length} rules`);
    
    // 4. Validate rules
    const validatedRules = this.validateRules(generatedRules);
    console.log(`✅ Validated ${validatedRules.length} rules`);
    
    // 5. Write output
    await this.writeOutput(validatedRules);
    console.log('🎉 Cursor init process completed!');
  }

  discoverSourceFiles() {
    const patterns = [
      `${this.sourceDir}/standards/*.md`,
      `${this.sourceDir}/lessons-learned/**/*.md`,
      `${this.sourceDir}/templates/*.md`
    ];
    
    let files = [];
    patterns.forEach(pattern => {
      const matches = glob.sync(pattern);
      files = files.concat(matches);
    });
    
    return files;
  }

  analyzeContent(sourceFiles) {
    const analyzed = [];
    
    sourceFiles.forEach(file => {
      const content = fs.readFileSync(file, 'utf8');
      const analysis = this.parseMarkdownContent(content, file);
      analyzed.push(analysis);
    });
    
    return analyzed;
  }

  parseMarkdownContent(content, filePath) {
    // Parse Markdown and extract rule-worthy content
    const sections = this.extractSections(content);
    const rules = this.extractRules(sections);
    
    return {
      filePath,
      sections,
      rules,
      metadata: this.extractMetadata(content)
    };
  }

  extractSections(content) {
    // Extract sections based on headers
    const sections = [];
    const lines = content.split('\n');
    let currentSection = null;
    
    lines.forEach(line => {
      if (line.startsWith('#')) {
        if (currentSection) {
          sections.push(currentSection);
        }
        currentSection = {
          title: line.replace(/^#+\s*/, ''),
          content: [line]
        };
      } else if (currentSection) {
        currentSection.content.push(line);
      }
    });
    
    if (currentSection) {
      sections.push(currentSection);
    }
    
    return sections;
  }

  extractRules(sections) {
    // Extract rules from sections
    const rules = [];
    
    sections.forEach(section => {
      const ruleContent = this.convertToRule(section);
      if (ruleContent) {
        rules.push(ruleContent);
      }
    });
    
    return rules;
  }

  convertToRule(section) {
    // Convert section to Cursor rule format
    const title = section.title;
    const content = section.content.join('\n');
    
    // Apply rule formatting
    const ruleContent = this.formatAsRule(title, content);
    
    return {
      title,
      content: ruleContent,
      source: section
    };
  }

  formatAsRule(title, content) {
    // Format content as Cursor rule
    return `# ${title}

${content}

---
**Generated by Agent OS Cursor Init Process**
**Source**: .agent-os framework
**Last Updated**: ${new Date().toISOString()}
`;
  }

  generateRules(analyzedContent) {
    const rules = [];
    
    analyzedContent.forEach(analysis => {
      analysis.rules.forEach(rule => {
        rules.push({
          filename: this.generateRuleFilename(rule.title),
          content: rule.content,
          source: rule.source
        });
      });
    });
    
    return rules;
  }

  generateRuleFilename(title) {
    // Convert title to filename
    return title
      .toLowerCase()
      .replace(/[^a-z0-9]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '') + '.mdc';
  }

  validateRules(generatedRules) {
    const validated = [];
    
    generatedRules.forEach(rule => {
      const validation = this.validateRule(rule);
      if (validation.isValid) {
        validated.push(rule);
      } else {
        console.warn(`⚠️ Rule validation failed for ${rule.filename}: ${validation.errors.join(', ')}`);
      }
    });
    
    return validated;
  }

  validateRule(rule) {
    const errors = [];
    
    // Check for required content
    if (!rule.content || rule.content.trim().length === 0) {
      errors.push('Empty content');
    }
    
    // Check for valid filename
    if (!rule.filename || rule.filename.length === 0) {
      errors.push('Invalid filename');
    }
    
    // Check for required sections
    if (!rule.content.includes('---')) {
      errors.push('Missing metadata section');
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }

  async writeOutput(validatedRules) {
    // Ensure output directories exist
    this.ensureDirectories();
    
    // Write rules to .cursor/rules/
    validatedRules.forEach(rule => {
      const outputPath = path.join(this.outputDir, rule.filename);
      fs.writeFileSync(outputPath, rule.content);
      console.log(`📝 Wrote ${rule.filename}`);
    });
    
    // Generate summary
    await this.generateSummary(validatedRules);
  }

  ensureDirectories() {
    [this.outputDir, this.generatedDir].forEach(dir => {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
    });
  }

  async generateSummary(validatedRules) {
    const summary = {
      generatedAt: new Date().toISOString(),
      totalRules: validatedRules.length,
      rules: validatedRules.map(rule => ({
        filename: rule.filename,
        title: rule.title,
        source: rule.source?.filePath
      }))
    };
    
    const summaryPath = path.join(this.generatedDir, 'init-summary.json');
    fs.writeFileSync(summaryPath, JSON.stringify(summary, null, 2));
    console.log(`📊 Generated summary: ${summaryPath}`);
  }
}

// Run the init process
if (require.main === module) {
  const init = new CursorInit();
  init.run().catch(console.error);
}

module.exports = CursorInit;
```


---
**Generated by Agent OS Cursor Init Process**
**Source**: .agent-os framework
**Last Updated**: 2025-08-05T00:12:13.516Z
**Type**: standard
